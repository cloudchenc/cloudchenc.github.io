---
title: 内存优化
tags:
categories:
---

```java
// 查看应用程序最高可用内存
int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
Log.d("TAG", "Max memory is " + maxMemory + "KB");
```

Bitmap加载
=========

BitmapFactory.Options  inJustDecodeBounds属性设置为null时  
BitmapFactory decodeXXX方法不会为bitmap分配内存，但会赋值图片的宽高值和图片类型  
从而根据情况对图片进行压缩

```java
BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);
int imageHeight = options.outHeight;
int imageWidth = options.outWidth;
String imageType = options.outMimeType;
```
为了避免OOM异常，最好在解析每张图片的时候都先检查一下图片的大小，除非你非常信任图片的来源，保证这些图片都不会超出你程序的可用内存。

+ 预估一下加载整张图片所需占用的内存
+ 为了加载这一张图片你所愿意提供多少内存
+ 用于展示这张图片的控件的实际大小
+ 当前设备的屏幕尺寸和分辨率

通过设置BitmapFactory.Options中inSampleSize的值实现对图片的压缩
```java
public static int calculateInSampleSize(BitmapFactory.Options options,
		int targetWidth, int targetHeight) {
	// 源图片的高度和宽度
	final int height = options.outHeight;
	final int width = options.outWidth;
	int inSampleSize = 1;
	if (height > targetHeight || width > targetWidth) {
		// 计算出实际宽高和目标宽高的比率
		final int heightRatio = Math.round((float) height / (float) targetHeight);
		final int widthRatio = Math.round((float) width / (float) targetWidth);
		// 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高
		// 一定都会大于等于目标的宽和高。
		inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;
	}
	return inSampleSize;
}
```
使用这个方法，首先你要将BitmapFactory.Options的inJustDecodeBounds属性设置为true，解析一次图片。然后将BitmapFactory.Options连同期望的宽度和高度一起传递到到calculateInSampleSize方法中，就可以得到合适的inSampleSize值了。  
之后再解析一次图片，使用新获取到的inSampleSize值，并把inJustDecodeBounds设置为false，就可以得到压缩后的图片了。
```java
public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
        int targetWidth, int targetHeight) {
	// 第一次解析将inJustDecodeBounds设置为true，来获取图片大小
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);
    // 调用上面定义的方法计算inSampleSize值
    options.inSampleSize = calculateInSampleSize(options, targetWidth, targetHeight);
    // 使用获取到的inSampleSize值再次解析图片
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}
```

图片缓存
=======

LruCache：主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。

为了能够选择一个合适的缓存大小给LruCache, 有以下多个因素应该放入考虑范围内
+ 你的设备可以为每个应用程序分配多大的内存？
+ 设备屏幕上一次最多能显示多少张图片？有多少图片需要进行预加载，因为有可能很快也会显示在屏幕上？
+ 你的设备的屏幕大小和分辨率分别是多少？一个超高分辨率的设备（例如 Galaxy Nexus) 比起一个较低分辨率的设备（例如 Nexus S），在持有相同数量图片的时候，需要更大的缓存空间。
+ 图片的尺寸和大小，还有每张图片会占据多少内存空间。
+ 图片被访问的频率有多高？会不会有一些图片的访问频率比其它图片要高？如果有的话，你也许应该让一些图片常驻在内存当中，或者使用多个LruCache 对象来区分不同组的图片。
+ 你能维持好数量和质量之间的平衡吗？有些时候，存储多个低像素的图片，而在后台去开线程加载高像素的图片会更加的有效。

```java
private LruCache<String, Bitmap> mMemoryCache;
 
@Override
protected void onCreate(Bundle savedInstanceState) {
	// 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。
	// LruCache通过构造函数传入缓存值，以KB为单位。
	int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
	// 使用最大可用内存值的1/8作为缓存的大小。
	int cacheSize = maxMemory / 8;
	mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {
		@Override
		protected int sizeOf(String key, Bitmap bitmap) {
			// 重写此方法来衡量每张图片的大小，默认返回图片数量。
			return bitmap.getByteCount() / 1024;
		}
	};
}
 
public void addBitmapToMemoryCache(String key, Bitmap bitmap) {
	if (getBitmapFromMemCache(key) == null) {
		mMemoryCache.put(key, bitmap);
	}
}
 
public Bitmap getBitmapFromMemCache(String key) {
	return mMemoryCache.get(key);
}
```

### 1. 减少对象的内存占用

+ 避免在 Android 里面使用 Enum
+ 使用更加轻量的数据结构
+ 使用更小的图片
+ 减少 Bitmap 对象的内存占用
  
### 2. 对内存对象进行复用

+ 复用系统自带的资源
+ 注意 ListView / GridView 的 Adapter 对 ConvertView 进行复用
+ 尽量的采用 StringBuilder
+ 尽量使用原字符串的 subString
+ 避免在 onDraw() 里面执行对象的创建
  
### 3. 避免对象的内存泄漏

+ 注意 Activity 的泄漏
    - 内部类引用导致 Activity 的泄漏
    - Activity Context 被传递到其他实例中，这可能导致自身被引用而发生泄漏
+ 尽量地采用 Application Context
+ 注意 Cursor 对象是否及时关闭
+ 注意 WebView 的泄漏: 开启另一个进程，通过AIDL与主进程通信  
+ 注意临时 Bitmap 对象的及时回收
+ 注意监听器的注销

### 4. 内存使用策略优化

+ 谨慎使用 large heap
+ 资源文件需要选择合适的文件夹进行存放
+ Try catch某些大内存分配的操作
+ 谨慎使用 static 对象
+ 特别留意单例对象中不合理的持有
+ 优化布局层次，减少内存消耗  
+ 谨慎使用多进程


参考资料：

https://blog.csdn.net/guolin_blog/article/details/9316683
https://blog.csdn.net/guolin_blog/article/details/9526203