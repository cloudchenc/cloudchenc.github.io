---
title: 内存泄漏修复实践
tags:
    - 性能优化
    - 内存泄漏
categories: Android
---

根本原因

一个对象实际的生命周期超出了它正常的生命周期


#### 单例模式

单例的生命周期和应用的生命周期一样长。如果一个对象已经没有用处，但是单例仍持有它的引用，那么在整个应用的生命周期中都不能被正常回收，从而导致内存泄漏。

```java

```

#### 匿名内部类

匿名类和内部类持有外部类的引用

解决：静态内部类和弱引用

View.setOnClickListener也是匿名内部类，但是之所以没有内存泄漏，是因为View在被移除前，清空了所有的监听器。
如果Activity存在，那么匿名内部类是一直会存在的，而且也会一直持有着Activity的引用，不泄露的原因和View的生命周期有关。
在View的生命周期的最后有个函数叫做onDetachedFromWindowInternal()，这个函数里会有移除掉所有View的监听器的操作，本质click事件也是通过handler去发送的，View呗销毁之前，会把对应的Runnable从handler里移除掉，因此这样不会导致内存泄漏。

##### Thread

##### Handler

##### Runnable

##### HandlerThread

##### DialogFragment

#### 集合引用对象

#### WebView
```java
    LinearLayout mRoot;
    WebView mWebView;
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mWebView = new WebView(getApplicationContext());
        mRoot = findViewById(R.id.root)
        mRoot.addView(mWebView)
    }

    @Override
    protected void onDestroy(){
        super.onDestroy();
        mRoot.removeAllViews();
        mWebView.destroy();
    }
```

#### 监听器

#### 静态变量

#### Context

1. Application Context

2. Activity Context

#### 动画

#### 第三方库（RxJava，EventBus等）

Histogram 和 Dominator Tree

### MAT

### LeakCanary