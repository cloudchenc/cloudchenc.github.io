---
title: 卡顿优化
tags:
categories: 性能优化
---

尽量提供一些具体的实例来展示信息

工具：

Systrace

TraceView

使用 Systrace 和 TraceView 来分析耗时

从实现原理引申出框架

原理：主线程的消息队列机制

1. 通过消息队列输入输出的时间差，同阈值进行对比
2. 开启线程，定时向主线程发送消息，记录发送时间，同主线程的执行时间进行对比

当判断为卡顿后，打印当前主线程的堆栈信息，但是有可能真正卡顿的方法已经执行过了，
那么可以获取多个堆栈的信息，过滤筛选重复的堆栈调用，会大概率找到耗时方法。

需要获取的一些信息：

手机信息：手机型号，系统版本，进程名称，应用版本，内置存储等
耗时信息：卡顿开始和结束时间
CPU使用信息：CPU信息，整体CPU使用率和本进程使用率
堆栈信息：

线下和线上的监控

shell命令分析cpu耗时

top

ps 

dumpsys cpuinfo

音视频编解码占用资源


线下卡顿优化工具

Cpu profiler

systrace

StrictMode


自动化卡顿检测方案

原理：它的原理源于Android的消息处理机制，一个线程不管有多少Handler，它只会有一个Looper存在，主线程执行的任何代码都会通过Looper.loop()方法执行。

而在Looper函数中，它有一个mLogging对象，这个对象在每个message处理前后都会被调用。主线程发生了卡顿，那一定是在dispatchMessage()方法中执行了耗时操作。那么，我们就可以通过这个mLogging对象对dispatchMessage()进行监控。

在Looper的loop()方法中，在其执行每一个消息（注释2处）的前后都由logging进行了一次打印输出。可以看到，在执行消息前是输出的">>>>> Dispatching to "，在执行消息后是输出的"<<<<< Finished to ",它们打印的日志是不一样的，我们就可以由此来判断消息执行的前后时间点。

所以，具体的实现可以归纳为如下步骤：

* 1、首先，我们需要使用Looper.getMainLooper().setMessageLogging()去设置我们自己的Printer实现类去打印输出logging。这样，在每个message执行的之前和之后都会调用我们设置的这个Printer实现类。
* 2、如果我们匹配到">>>>> Dispatching to "之后，我们就可以执行一行代码：也就是在指定的时间阈值之后，我们在子线程去执行一个任务，这个任务就是去获取当前主线程的堆栈信息以及当前的一些场景信息，比如：内存大小、电脑、网络状态等。
* 3、如果在指定的阈值之内匹配到了"<<<<< Finished to "，那么说明message就被执行完成了，则表明此时没有产生我们认为的卡顿效果，那我们就可以将这个子线程任务取消掉。

其最大的作用还是在线上环境或者自动化monkey测试的环节进行大范围的log采集与分析，对于分析的纬度，可以从以下两个纬度来进行：

* 卡顿时间。
* 根据同堆栈出现的卡顿次数来进行排序和归类。

抓取多个堆栈进行排重，然后上传
