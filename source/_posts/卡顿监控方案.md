---
title: 卡顿监控方案
date: 2021-07-13 11:52:15
tags:
categories:
---

## WatchDog

子线程轮询UI线程

原理：不断向UI线程发送Message，每隔一段时间检查一次刚刚发送的Message是否被处理，如果没有被处理，则说明这段时间主线程被卡住了

优点：简单，稳定，结果论，可以监控到各种类型的卡顿
缺点：轮询不优雅，不环保，有不确定性，随机漏报

## Looper Printer

替换主线程Looper的Printer，从而监控dispatchMessage的执行时间

无论是通过反射替换Looper的mLogging还是通过setMessageLogging设置printer，我们只需要替换主线程Looper的printer对象，
通过计算执行dispatchMessage方法之后和之前打印字符串的时间的差值，就可以拿到到dispatchMessage方法执行的时间。
而大部分的主线程的操作最终都会执行到这个dispatchMessage方法中

优点：不会随机漏报，无需轮询，一劳永逸
缺点：某些类型的卡顿无法被监控到 
    1. View的TouchEvent中的卡顿这种方案是无法监控的 通过PLT Hook，成功hook到libinput.so中的recvfrom和sendto方法，使用我们自己的方法进行替换。当调用到了recvfrom时，说明我们的应用接收到了Touch事件，当调用到了sendto时，说明这个Touch事件已经被成功消费掉了，当两者的时间相差过大时即说明产生了一次Touch事件的卡顿。
    2. IdleHandler的queueIdle()回调方法也是无法被监控的  反射IdleHandler中的的queueIdle方法，监控queueIdle的执行时间
    3. SyncBarrier（同步屏障）的泄漏同样无法被监控到  如果我们通过反射mMessage，发现当前的Message的target为null，并且通过这个Message的when发现其已经存在很久了，这个时候我们合理怀疑产生了SyncBarrier的泄漏（但还不能完全确定，因为如果当时因为其他原因导致主线程卡死，也可能会导致这种现象），然后再发送一个同步消息和一个异步消息，如果异步消息被处理了，但是同步消息一直无法被处理，这时候就说明产生了SyncBarrier的泄漏。如果激进一些，这个时候我们甚至可以反射调用MessageQueue的removeSyncBarrier方法，手动把这个SyncBarrier移除掉，从而从错误状态中恢复。
    
https://mp.weixin.qq.com/s/3dubi2GVW_rVFZZztCpsKg