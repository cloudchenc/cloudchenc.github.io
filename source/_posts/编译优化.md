---
title: 编译优化
date: 2020-07-22 18:14:46
tags:
    - 性能优化
    - Gradle
categories: Android
---

### 历史优化方案

#### maven 代理优化 sync 时间

##### 背景

gradle 工程中会在 repositories 中 添加一些 maven 仓库地址，作为组件依赖获取的查找路径，
是按照 maven 仓库配置的顺序依次查找的，如果某个组件存在于最后一个仓库中，那前面的多个仓库会依次发起网络请求查找，
并且在请求失败后才查找下一个，如果大多数组件存在位置比较靠后，就会造成累加的查找时间过长。

##### 优化方案

1. 搭建公司 maven 私服，设置代理仓库，为google，jcenter，mavenCentral等仓库配置代理，
在代理仓库创建好后，在 Negative Cache 配置项中关闭 cache 开关：
如果查找时没有找到依赖库时会缓存失败结果，一段时间内不会重新去 maven 仓库查找对应依赖库，
即使 maven 仓库中已经有该版本的依赖库，查找时仍然返回失败的结果。

2. 建立仓库组，统一管理所有仓库，依赖查找时只需要在这个仓库组内查找，降低遍历仓库时的网络请求耗时

#### 模块 aar 化

##### 背景

项目如果使用了组件化和模块化开发时，会产生大量的子模块，如果这些子模块都 inclue 在项目中，在 clean build 的过程中，
就需要重新编译所有的子模块代码。在团队开发时，开发人员往往只负责少数几个模块，无需改动大多数模块的代码，
所以别的模块的配置和编译时间就成了负担。

##### 优化方案

将所有模块打包成 aar，在项目中默认通过 maven 依赖这些编译好的组件，
而在改动模块代码时，通过配置项将该模块的依赖形式调整为源码依赖，做到编译时只编译改动的模块。
弊端是需要开发人员自觉将模块打包成 aar，并在该模块修改完成后，改回依赖形式。

更新方案：
1. 开发过程中，master 分支上的代码一定是全部依赖 aar的，除了 app 模块 没有任何子模块是源码引入的
2. 需要修改对应模块时，通过修改 local.properties 里的 INCLUDES 参数指定源码引入的模块
3. 开发完成后，push 代码到远端，触发代码合并流程后，在 ci 预编译过程与合并目标分支做对比，检测修改的模块，
    将这些模块按照依赖关系打包成新的 aar 替换原来的旧版本，这就保证了每次代码合并后，master 分支上的依赖全部是 aar 依赖
    
Tips：
    ci / cb ：Continuous Integration 持续集成, Continuous Delivery 持续交付, 都是 GitLab 提供的服务

##### 收益

将源码依赖改为 aar 依赖后，clean build 耗时从7，8分钟降低至4，5分钟，接近50%

#### 增量 java/kotlin 编译

##### 背景

在非 clean build 的情况下，更改 java/kotlin 代码虽然会做增量编译， 但是 gradle 会根据依赖关系，
为了保证编译的正确性，可能选择重新编译代码，这就导致了增量编译的失效。

##### 优化方案

所以为了快速编译展示结果，可以在编译正确性和编译速度上做一个折中：
1. 禁用原始的 javac/kotlinCompile 等 task, 手动实现代码增量修改判断，只编译修改的代码。
2. 动态禁用 kapt 相关的 task，降低 kapt，kaptGenerateStub 等 task 的耗时。

##### 小结

上述三个方案虽然在涉及常量修改，方法签名变更等方面存在一些并不常见的问题（如常量内联），
但极大的提升了编译效率，利大于弊。

Tips：
kapt：Kotlin Annotation Processing Tool（Kotlin注释处理工具）
常量内联：静态编译器 javac 在编译时会内联一些静态最终变量，并把值直接放入常量池中。

### 编译耗时恶化

1. kotlin 大量使用，kapt 新增了很多注解处理逻辑。
2. 引入 java8 支持，语法糖增加了编译耗时
3. 大量的字节码插桩需求，添加了很多 transform，大幅度提升了增量编译耗时

### 近期优化方案

#### app 壳模块 kapt 优化

##### 背景

经历过模块化，组件化重构后，app 模块只是一个空壳。
但从 build profile（执行 gradle 命令时添加 --profile 参数会在编译完成后输出相关 task 耗时的统计文件）的数据来看：
只有 2 个类的 app 模块 kapt (annotationProcessor注解处理) 却耗时近 1 分钟。

通过分析这 2 个类的代码发现，使用了 6 种 kapt 库，但实际生效的只是其中 ServiceImpl 一个注解（内部的 SerivceManager 框架，
用于指定生产 Proxy 类，对模块之间代码调用进行解耦），最终编译得到的是 2 个固定的 Proxy 类。

##### 优化方案

把固定生成的 Proxy 类从 generate 目录下移动到 src 目录下，同时禁止 app 模块中 kapt 相关的 task, 并添加管控方案，
检测到不合理的情况马上抛出异常，防止其他人添加新增的 kapt 库。
```java
project.afterEvaluate{
    android.applicationVariants.each { variant ->
        project.tasks.getByName("kapt${variant.name.capitalize()}Kotlin").enabled = false
        project.tasks.getByName("kaptGenerateStubs${variant.name.capitalize()}Kotlin").enabled = false
    }   
    def set = new HashSet<String>()
    android.applicationVariants.each { variant ->
        configurations.getByName("kapt").dependencies.each { depend ->
            set.add("${depend.getGroup()}:${depend.getName()}:${depend.getVersion()}")
        }
    }
    if (!set.isEmpty()) {
        throw new IllegalThreadException(("已禁止 app 模块所有 kapt, 请勿添加新的 kapt"))
    }
}
```

##### 收益

1. mac clean build 减少了 40s 耗时
2. ci clean build 减少了 20s 耗时

#### kapt 隔离优化

##### 背景

项目中为了方便，定义了 library.gradle, 作用是定义项目中通用的 Android dsl (domain-specific language) 和共有的基础依赖，
因此所有的子模块都 apply 了这个文件，但是后续的开发中，这个文件被不同的业务添加新的 kapt 注解处理库，在全源码编译时，所有子模块
都得执行 library 模块中定义的全部 kapt, 即使该模块不需要用到注解处理。

问题的根源在于：相比纯 java 模块的注解处理，kotlin代码需要先通过 kaptGenerateStub 将 kt 文件转换为 java，让 apt 处理程序能够统一的面向 java 做注解扫描和处理。
但实际上很多模块没有任何kapt处理操作，所以就白白做了一次 kt 到 java 的转化操作，这就导致引入的模块越多，累计的无效耗时越多。

##### 优化方案

需要扫描所有子模块，区分哪些模块用到了 kapt，而没有用到的就禁用掉 kapt 相关 task：
1. 获取 kapt configuration 的所有依赖，可以得到 kapt 依赖库的 jar 包，利用 asm 获取所有 annotation
2. 遍历所有 subproject 的 sourceset 下所有 java 文件，kt 文件，解析 import 信息，看是否有前面解析到的 annotation
3. package task 完成后遍历所有的 subproject 中 generate/apt, generate/kapt 目录下生成的 java 文件

获取到不实际生成 kapt 内容的模块后，开始拆分这些模块，从 apply library.gradle 改为没有 kapt 相关的 apply library-api.gradle, 该文件除了禁用 kapt 外，其他与 library 保持一致。
为了避免后续新添了注解却没有任何输出，对 library-api 模块依赖的注解做隔离优化，即把这些注解库全部 exclude 掉，在尝试使用注解时会因为获取不到引用，发现依赖的注解库被移除的问题。
另外当编译出现错误时，gradle 插件对注解符号进行解析，如果发现是被隔离优化的注解库，就提示将 apply library-api.gradle 替换为 apply library.gradle，减少优化方案对业务层的侵入。

##### 收益

1. mac 全源码编译 减少了 58s 耗时
2. ci 机器由于 cpu 核数更多, task 并发性能更好，减少了 10s 耗时

#### transform 优化

##### 背景



##### 优化方案

##### 收益



参考:  
https://juejin.im/post/5f144b2f6fb9a07e6f7b7fce